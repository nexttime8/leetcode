## 1 两数之和

1. (实现方法一)双层循环暴力解![双层循环暴力解性能比较](image-1.png)
2. (实现方法二)用 Map 实现,学过 Map\且掌握了,但是不会用来解题![Map实现性能比较](image-2.png)
3. (实现方法三)用 Object 实现![Object实现性能比较](image-3.png)
4. 无论是 Object 实现,还是 Map 实现,看似是求两数之和
   1. 实则要有两数之差的理念
   2. 将值作为键,索引作为值存入 Map 对象和 Object 对象

## 704 二分查找

1. tips
   1. while 循环条件有没有=
   2. if 条件是 middle-1 还是 middle
2. 左闭右开?左闭右闭?两种情况写代码
3. int 型相加越界?
4. (实现方法一)二分查找左闭右闭实现![二分查找左闭右闭实现性能比较](image.png)
5. (实现方法二)二分查找左闭右开实现![二分查找左闭右开实现性能比较](image-4.png),比较发现左闭右开实现效果更好
6. 两次调整
   1. 第一次调整:js 中输出小数!不会自动向下取整;加上 parseInt()强制类型转换
   2. 第二次调整:考虑 target 不存在的情况[没认真看题目:如果目标值存在返回下标，否则返回 -1]

## 4 寻找两个正序数组的中位数

1. 一些知识点的巩固
   1. 数组解构再合并,新数组长度是两个原数组长度之和
   2. sort 方法,是生成新数组;sort 方法的时间复杂度
2. 一次调整![第一次尝试出错](image-5.png)
   1. 第一次调整:取数组中的元素的索引只能是整数,加上 parseInt()强制类型转换,或者 Math.floor()
3. (实现方法一)时间复杂度不符合要求(m+n)log(m+n).数组结构合并,sort 方法对数组进行排序,分两类情况返回中位数![解构加排序方法实现性能比较](image-6.png)
   - 自己也意识到了,没有利用到原本的两个数组是有序的,这个条件
4. (实现方法二)88 题,利用归并排序实现,合并两个有序数组,时间复杂度 O(n+m)
5. (实现方法三)二分法,时间复杂度 O(log(min(m,n))),不需要完全合并两个数组
   1. 看到时间复杂度要求 log,就要想到二分
   2. 无论是一个数组还是两个数组,都可以利用二分查找的思想;把数组分成两个部分,始终保持一个规则(左右个数相等或者左少一或者左多一),此外保证左边所有元素<=右边所有元素.(用以下任意一种逻辑都可以实现)
      1. 保证第一个数组的左边的最大元素<=第二个数组的右边的最小元素
      2. 保证第二个数组的左边的最大元素<=第一个数组的右边的最小元素
   3. 针对总长度分情况
      1. 总长度为奇数,如果左边多一个元素,则左边最大的是中位数
      2. 总长度为偶数,则左边最大和右边最小的均值为中位数
   4. 用下取整,可以不用对总长度是奇数还是偶数进行讨论?
      1. Math.floor((m+n+1)/2)
   5. 要保证较短数组的左右两侧都有元素,因此以较短的数组确定分割线位置;若无法保证有元素,需要进行特殊讨论
   6.
